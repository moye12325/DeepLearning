'''假设给定分词列表: ["是谁", "敲动", "我心"]

对应的数值映射列表为: [1, 34, 21]

我们可以认为数值映射列表中的每个数字是词汇特征.

除此之外, 我们还可以把"是谁"和"敲动"两个词共同出现且相邻也作为一种特征加入到序列列表中,

假设1000就代表"是谁"和"敲动"共同出现且相邻

此时数值映射列表就变成了包含2-gram特征的特征列表: [1, 34, 21, 1000]

这里的"是谁"和"敲动"共同出现且相邻就是bi-gram特征中的一个.

"敲动"和"我心"也是共现且相邻的两个词汇, 因此它们也是bi-gram特征.

假设1001代表"敲动"和"我心"共同出现且相邻

那么, 最后原始的数值映射列表 [1, 34, 21] 添加了bi-gram特征之后就变成了 [1, 34, 21, 1000, 1001]'''

ngram_range = 2


def create_ngram_set(input_list):
    """
        description: 从数值列表中提取所有的n-gram特征
        :param input_list: 输入的数值列表, 可以看作是词汇映射后的列表,
                           里面每个数字的取值范围为[1, 25000]
        :return: n-gram特征组成的集合

        eg:
        >>> create_ngram_set([1, 4, 9, 4, 1, 4])
        {(4, 9), (4, 1), (1, 4), (9, 4)}
        """
    return set(zip(*[input_list[i:] for i in range(ngram_range)]))


input_list = [1, 3, 2, 1, 5, 3]
res = create_ngram_set(input_list)
print(res)

# 给定一段文本序列, 其中n个词或字的相邻共现特征即n-gram特征,
# 常用的n-gram特征是bi-gram和tri-gram特征, 分别对应n为2和3.


# 一般模型的输入需要等尺寸大小的矩阵,
# 因此在进入模型前需要对每条文本数值映射后的长度进行规范,
# 此时将根据句子长度分布分析出覆盖绝大多数文本的合理长度,
# 对超长文本进行截断, 对不足文本进行补齐(一般使用数字0),
# 这个过程就是文本长度规范.

from keras.preprocessing import sequence

# cutlen根据数据分析中句子长度分布，覆盖90%左右语料的最短长度.
# 这里假定cutlen为10
cutlen = 10


def padding(x_train):
    """
    description: 对输入文本张量进行长度规范
    :param x_train: 文本的张量表示, 形如: [[1, 32, 32, 61], [2, 54, 21, 7, 19]]
    :return: 进行截断补齐后的文本张量表示
    """
    # 使用sequence.pad_sequences即可完成
    return sequence.pad_sequences(x_train, cutlen)


# 假定x_train里面有两条文本, 一条长度大于10, 一天小于10
x_train = [[1, 23, 5, 32, 55, 63, 2, 21, 78, 32, 23, 1],
           [2, 32, 1, 23, 1]]

res = padding(x_train)
print(res)

# 文本长度规范的作用

# 一般模型的输入需要等尺寸大小的矩阵,
# 因此在进入模型前需要对每条文本数值映射后的长度进行规范,
# 此时将根据句子长度分布分析出覆盖绝大多数文本的合理长度, 对超长文本进行截断,
# 对不足文本进行补齐(一般使用数字0), 这个过程就是文本长度规范.